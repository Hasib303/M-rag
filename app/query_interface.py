#!/usr/bin/env python3
"""
Interactive Query Interface for Multilingual RAG System
Allows users to input queries and get semantic search results from the vector database.
"""

import sys
import os
from typing import List, Dict, Any, Optional
from pathlib import Path
import json
from datetime import datetime

# Add current directory to path for imports
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from vector_database import VectorRAGSystem
from chunk_embedder import ChunkEmbedder

class QueryInterface:
    def __init__(self, extracted_text_file: str = "extracted_text.txt", 
                 vector_db_path: str = "vector_database",
                 chunk_size: int = 400, overlap_size: int = 50):
        
        self.vector_rag = VectorRAGSystem(
            extracted_text_file=extracted_text_file,
            chunk_size=chunk_size, 
            overlap_size=overlap_size,
            vector_db_path=vector_db_path
        )
        self.is_ready = False
        self.query_history = []
    
    def initialize_system(self, force_rebuild: bool = False) -> bool:
        """Initialize or load the vector RAG system."""
        print("ЁЯФз Initializing Multilingual RAG System...")
        
        # Check if vector database already exists
        db_path = Path(self.vector_rag.vector_db.db_path)
        index_file = db_path / "faiss_index.bin"
        metadata_file = db_path / "metadata.db"
        
        if not force_rebuild and index_file.exists() and metadata_file.exists():
            print("ЁЯУБ Found existing vector database, loading...")
            try:
                # Load existing vector database
                if self.vector_rag.vector_db.load_index():
                    # Load embedder components for query processing
                    embedder_files = ["chunk_embeddings.pkl", "embedded_chunks.json"]
                    if all(Path(f).exists() for f in embedder_files):
                        self.vector_rag.embedder.load_embeddings()
                        self.is_ready = True
                        print("тЬЕ Successfully loaded existing system!")
                        return True
                    else:
                        print("тЪая╕П  Embedder files missing, rebuilding...")
                        force_rebuild = True
                else:
                    print("тЪая╕П  Failed to load index, rebuilding...")
                    force_rebuild = True
            except Exception as e:
                print(f"тЪая╕П  Error loading existing system: {e}")
                force_rebuild = True
        
        if force_rebuild or not self.is_ready:
            print("ЁЯПЧя╕П  Building new vector database...")
            if self.vector_rag.initialize():
                self.is_ready = True
                print("тЬЕ System initialized successfully!")
                return True
            else:
                print("тЭМ Failed to initialize system")
                return False
        
        return self.is_ready
    
    def process_query(self, query: str, max_results: int = 3, 
                     min_similarity: float = 0.1) -> Dict[str, Any]:
        """Process a user query and return results."""
        if not self.is_ready:
            return {"error": "System not initialized"}
        
        print(f"ЁЯФН Processing query: '{query}'")
        
        # Get embedding-based search results
        search_results = self.vector_rag.search(query, top_k=max_results)
        
        # Filter by minimum similarity
        filtered_results = [
            result for result in search_results 
            if result.get('similarity_score', 0) >= min_similarity
        ]
        
        # Format response
        response = {
            "query": query,
            "timestamp": datetime.now().isoformat(),
            "results_found": len(filtered_results),
            "search_results": filtered_results,
            "formatted_answer": self._format_answer(filtered_results),
            "sources": [
                {
                    "chunk_id": result["chunk_id"],
                    "similarity": f"{result['similarity_score']:.3f}",
                    "rank": result["rank"]
                } for result in filtered_results
            ]
        }
        
        # Add to query history
        self.query_history.append({
            "query": query,
            "timestamp": response["timestamp"],
            "results_count": len(filtered_results)
        })
        
        return response
    
    def _format_answer(self, results: List[Dict[str, Any]]) -> str:
        """Format search results into a readable answer."""
        if not results:
            return "ржжрзБржГржЦрж┐ржд, ржЖржкржирж╛рж░ ржкрзНрж░рж╢рзНржирзЗрж░ ржЬржирзНржп ржХрзЛржи ржкрзНрж░рж╛рж╕ржЩрзНржЧрж┐ржХ рждржерзНржп ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред"
        
        answer_parts = []
        for i, result in enumerate(results, 1):
            similarity = result.get('similarity_score', 0)
            text = result.get('text', '')
            
            # Truncate very long texts
            if len(text) > 500:
                text = text[:500] + "..."
            
            answer_parts.append(
                f"ЁЯУД ржЕржВрж╢ {i} (рж╕рж╛ржжрзГрж╢рзНржп: {similarity:.3f}):\n{text}"
            )
        
        return "\n\n" + "="*50 + "\n\n".join(answer_parts)
    
    def interactive_mode(self):
        """Run interactive query mode."""
        print("\n" + "="*60)
        print("ЁЯМЯ рж╕рзНржмрж╛ржЧрждржо! Multilingual RAG Query Interface")
        print("="*60)
        
        if not self.is_ready:
            print("тЭМ System not ready. Please initialize first.")
            return
        
        # Show system stats
        stats = self.vector_rag.vector_db.get_stats()
        print(f"ЁЯУК Vector Database: {stats['total_vectors']} vectors loaded")
        print(f"ЁЯФз Index Type: {stats['index_type']}")
        print("\nЁЯТб Tips:")
        print("  - ржЖржкржирж┐ ржмрж╛ржВрж▓рж╛ ржмрж╛ ржЗржВрж░рзЗржЬрж┐рждрзЗ ржкрзНрж░рж╢рзНржи ржХрж░рждрзЗ ржкрж╛рж░рзЗржи")
        print("  - 'quit', 'exit', ржмрж╛ 'q' ржЯрж╛ржЗржк ржХрж░рзЗ ржмрзЗрж░ рж╣ржи")
        print("  - 'history' ржЯрж╛ржЗржк ржХрж░рзЗ ржЖржЧрзЗрж░ ржкрзНрж░рж╢рзНржиржЧрзБрж▓рзЛ ржжрзЗржЦрзБржи")
        print("  - 'stats' ржЯрж╛ржЗржк ржХрж░рзЗ рж╕рж┐рж╕рзНржЯрзЗржо рждржерзНржп ржжрзЗржЦрзБржи")
        print("\n" + "-"*60)
        
        while True:
            try:
                # Get user input
                query = input("\nЁЯдФ ржЖржкржирж╛рж░ ржкрзНрж░рж╢рзНржи рж▓рж┐ржЦрзБржи: ").strip()
                
                if not query:
                    continue
                
                # Handle special commands
                if query.lower() in ['quit', 'exit', 'q', 'ржмрзЗрж░', 'рж╢рзЗрж╖']:
                    print("ЁЯСЛ ржзржирзНржпржмрж╛ржж! ржЖржмрж╛рж░ ржЖрж╕ржмрзЗржиред")
                    break
                
                elif query.lower() in ['history', 'ржЗрждрж┐рж╣рж╛рж╕']:
                    self._show_history()
                    continue
                
                elif query.lower() in ['stats', 'рждржерзНржп']:
                    self._show_stats()
                    continue
                
                elif query.lower() in ['help', 'рж╕рж╛рж╣рж╛ржпрзНржп']:
                    self._show_help()
                    continue
                
                # Process the query
                print("\nтП│ ржЕржирзБрж╕ржирзНржзрж╛ржи ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...")
                result = self.process_query(query, max_results=3)
                
                # Display results
                if result.get("error"):
                    print(f"тЭМ рждрзНрж░рзБржЯрж┐: {result['error']}")
                elif result["results_found"] == 0:
                    print("ЁЯд╖ ржжрзБржГржЦрж┐ржд, ржЖржкржирж╛рж░ ржкрзНрж░рж╢рзНржирзЗрж░ ржЬржирзНржп ржХрзЛржи ржЙрждрзНрждрж░ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред")
                    print("ЁЯТб ржЕржирзНржп рж╢ржмрзНржж ржмрж╛ ржмрж╛ржХрзНржп ржжрж┐ржпрж╝рзЗ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред")
                else:
                    print(f"\nтЬЕ {result['results_found']}ржЯрж┐ ржкрзНрж░рж╛рж╕ржЩрзНржЧрж┐ржХ ржЙрждрзНрждрж░ ржкрж╛ржУржпрж╝рж╛ ржЧрзЗржЫрзЗ:")
                    print(result["formatted_answer"])
                    
                    # Show sources
                    print(f"\nЁЯУЪ рждржерзНржпрж╕рзВрждрзНрж░:")
                    for source in result["sources"]:
                        print(f"  тАв {source['chunk_id']} (рж╕рж╛ржжрзГрж╢рзНржп: {source['similarity']})")
                
            except KeyboardInterrupt:
                print("\nЁЯСЛ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржмржирзНржз ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...")
                break
            except Exception as e:
                print(f"тЭМ рждрзНрж░рзБржЯрж┐ ржШржЯрзЗржЫрзЗ: {str(e)}")
    
    def _show_history(self):
        """Show query history."""
        if not self.query_history:
            print("ЁЯУЬ ржХрзЛржи ржкрзНрж░рж╢рзНржирзЗрж░ ржЗрждрж┐рж╣рж╛рж╕ ржирзЗржЗред")
            return
        
        print(f"\nЁЯУЬ рж╕рж╛ржорзНржкрзНрж░рждрж┐ржХ {len(self.query_history)}ржЯрж┐ ржкрзНрж░рж╢рзНржи:")
        for i, entry in enumerate(self.query_history[-5:], 1):  # Show last 5
            timestamp = datetime.fromisoformat(entry['timestamp']).strftime("%H:%M:%S")
            print(f"  {i}. [{timestamp}] {entry['query']} ({entry['results_count']}ржЯрж┐ ржлрж▓рж╛ржлрж▓)")
    
    def _show_stats(self):
        """Show system statistics."""
        stats = self.vector_rag.vector_db.get_stats()
        print(f"\nЁЯУК рж╕рж┐рж╕рзНржЯрзЗржо рждржерзНржп:")
        print(f"  ЁЯФв Total Vectors: {stats['total_vectors']}")
        print(f"  ЁЯУР Vector Dimension: {stats['dimension']}")
        print(f"  ЁЯПЧя╕П  Index Type: {stats['index_type']}")
        print(f"  ЁЯУД Total Chunks: {stats['total_chunks']}")
        print(f"  ЁЯТ╛ Database Path: {stats['database_path']}")
        print(f"  ЁЯХР Queries Made: {len(self.query_history)}")
    
    def _show_help(self):
        """Show help information."""
        print(f"\nЁЯЖШ рж╕рж╛рж╣рж╛ржпрзНржп:")
        print(f"  ЁЯУЭ Commands:")
        print(f"    тАв 'history' - ржкрзНрж░рж╢рзНржирзЗрж░ ржЗрждрж┐рж╣рж╛рж╕ ржжрзЗржЦрзБржи")
        print(f"    тАв 'stats' - рж╕рж┐рж╕рзНржЯрзЗржо рждржерзНржп ржжрзЗржЦрзБржи")
        print(f"    тАв 'help' - ржПржЗ рж╕рж╛рж╣рж╛ржпрзНржп ржжрзЗржЦрзБржи")
        print(f"    тАв 'quit' - ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржмржирзНржз ржХрж░рзБржи")
        print(f"  ЁЯФН Query Tips:")
        print(f"    тАв рж░ржмрзАржирзНржжрзНрж░ржирж╛рже рж╕ржорзНржкрж░рзНржХрзЗ ржмрж▓рзБржи")
        print(f"    тАв ржЕржкрж░рж┐ржЪрж┐рждрж╛ ржЧрж▓рзНржкрзЗрж░ ржЪрж░рж┐рждрзНрж░ ржХрж╛рж░рж╛?")
        print(f"    тАв рж╢ржмрзНржжрж╛рж░рзНрже")
        print(f"    тАв ржкрзНрж░рж╢рзНржи ржУ ржЙрждрзНрждрж░")
    
    def batch_query(self, queries: List[str], output_file: str = None) -> List[Dict[str, Any]]:
        """Process multiple queries at once."""
        if not self.is_ready:
            print("тЭМ System not ready")
            return []
        
        results = []
        print(f"ЁЯФД Processing {len(queries)} queries...")
        
        for i, query in enumerate(queries, 1):
            print(f"  Processing {i}/{len(queries)}: {query}")
            result = self.process_query(query)
            results.append(result)
        
        # Save to file if specified
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(results, f, ensure_ascii=False, indent=2)
            print(f"ЁЯТ╛ Results saved to: {output_file}")
        
        return results

def main():
    """Main function to run the query interface."""
    print("ЁЯЪА Starting Multilingual RAG Query Interface...")
    
    # Initialize the interface
    interface = QueryInterface(
        extracted_text_file="extracted_text.txt",
        vector_db_path="vector_database"
    )
    
    # Check command line arguments
    if len(sys.argv) > 1:
        if sys.argv[1] == "--rebuild":
            print("ЁЯФД Force rebuilding vector database...")
            success = interface.initialize_system(force_rebuild=True)
        elif sys.argv[1] == "--batch":
            # Batch mode with predefined queries
            test_queries = [
                "рж░ржмрзАржирзНржжрзНрж░ржирж╛рже ржарж╛ржХрзБрж░",
                "ржЕржкрж░рж┐ржЪрж┐рждрж╛ ржЧрж▓рзНржкрзЗрж░ ржорзВрж▓ ржЪрж░рж┐рждрзНрж░ ржХрзЗ?",
                "ржПржЗ ржЧрж▓рзНржкрзЗрж░ ржкрзНрж░ржзрж╛ржи ржмрж┐рж╖ржпрж╝ ржХрж┐?",
                "рж╢ржмрзНржжрж╛рж░рзНрже ржУ ржЕрж░рзНрже",
                "HSC ржкрж░рзАржХрзНрж╖рж╛рж░ ржкрзНрж░рж╢рзНржи"
            ]
            
            if interface.initialize_system():
                results = interface.batch_query(test_queries, "batch_results.json")
                print(f"тЬЕ Processed {len(results)} queries")
            return
        else:
            print(f"тЭУ Unknown argument: {sys.argv[1]}")
            print("Usage: python query_interface.py [--rebuild|--batch]")
            return
    else:
        success = interface.initialize_system()
    
    if success:
        # Start interactive mode
        interface.interactive_mode()
    else:
        print("тЭМ Failed to initialize system. Please check your files:")
        print("  тАв extracted_text.txt - should contain your document text")
        print("  тАв Make sure all required packages are installed")

if __name__ == "__main__":
    main()